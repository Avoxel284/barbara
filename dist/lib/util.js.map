{"version":3,"file":"util.js","sourceRoot":"","sources":["../../src/lib/util.ts"],"names":[],"mappings":";;;AAKA,qCAAkC;AAOlC,SAAgB,YAAY,CAAC,GAAW,EAAE,GAAW;IACpD,GAAG,GAAG,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;IACrB,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;IACtB,OAAO,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,EAAE,GAAG,CAAC,GAAG,GAAG,GAAG,GAAG,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC;AAC1D,CAAC;AAJD,oCAIC;AAKD,SAAgB,QAAQ,CAAC,OAAY;IACpC,IAAI,CAAC,IAAA,eAAM,EAAC,cAAc,CAAC;QAAE,OAAO;IACpC,OAAO,CAAC,GAAG,CAAC,wCAAwC,EAAE,OAAO,CAAC,CAAC;AAEhE,CAAC;AAJD,4BAIC;AAKD,SAAgB,kBAAkB,CAAC,IAAY;IAC9C,IAAI,GAAG,GAAG,CAAC,CAAC,CAAC,IAAI,GAAG,IAAI,CAAC,CAAC;IAC1B,IAAI,IAAI,GAAG,CAAC,CAAC,CAAC,CAAC,IAAI,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC,CAAC;IAClC,IAAI,IAAI,GAAG,CAAC,CAAC,IAAI,GAAG,EAAE,CAAC;IACvB,IAAI,GAAG,GAAG,EAAE,CAAC;IACb,IAAI,GAAG,GAAG,CAAC;QAAE,GAAG,IAAI,EAAE,GAAG,GAAG,GAAG,GAAG,GAAG,CAAC,IAAI,GAAG,EAAE,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC;IAE5D,GAAG,IAAI,EAAE,GAAG,IAAI,GAAG,GAAG,GAAG,CAAC,IAAI,GAAG,EAAE,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC;IAChD,GAAG,IAAI,EAAE,GAAG,IAAI,CAAC;IACjB,OAAO,GAAG,CAAC;AACZ,CAAC;AAVD,gDAUC;AAKD,SAAgB,kBAAkB,CAAC,IAAY;IAC9C,IAAI,CAAC,IAAI;QAAE,OAAO,CAAC,CAAC;IACpB,MAAM,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;IAE7B,QAAQ,IAAI,CAAC,MAAM,EAAE;QACpB,KAAK,CAAC;YACL,OAAO,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,GAAG,EAAE,GAAG,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;YAChF,MAAM;QAEP,KAAK,CAAC;YACL,OAAO,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,GAAG,EAAE,GAAG,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;YAClD,MAAM;QAEP;YACC,OAAO,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;YACzB,MAAM;KACP;AACF,CAAC;AAjBD,gDAiBC","sourcesContent":["/**\n * Avoxel284 2022\n * Barbara Music Module\n */\n\nimport { getKey } from \"./config\";\n\n/**\n * Returns a random integer between two given integers\n * @param min Minimum\n * @param max Maximum\n */\nexport function getRandomInt(min: number, max: number): number {\n\tmin = Math.ceil(min);\n\tmax = Math.floor(max);\n\treturn Math.floor(Math.random() * (max - min + 1)) + min;\n}\n\n/**\n * Debug logging function for internal use\n */\nexport function debugLog(message: any) {\n\tif (!getKey(\"CONFIG_DEBUG\")) return;\n\tconsole.log(`\\u001b[36;1m[ Barbara Debug ]\\u001b[0m`, message);\n\t// \\u001b[36;1m\n}\n\n/**\n * Returns a timestamp such as `3:10`, `45:32` or `132:44:19` from a given amount of seconds\n */\nexport function getTimeFromSeconds(time: number) {\n\tlet hrs = ~~(time / 3600);\n\tlet mins = ~~((time % 3600) / 60);\n\tlet secs = ~~time % 60;\n\tlet ret = \"\";\n\tif (hrs > 0) ret += \"\" + hrs + \":\" + (mins < 10 ? \"0\" : \"\");\n\n\tret += \"\" + mins + \":\" + (secs < 10 ? \"0\" : \"\");\n\tret += \"\" + secs;\n\treturn ret;\n}\n\n/**\n * Returns seconds from a given timestamp such as `3:10`, `45:32` or `132:44:19`\n */\nexport function getSecondsFromTime(time: string) {\n\tif (!time) return 0;\n\tconst args = time.split(\":\");\n\n\tswitch (args.length) {\n\t\tcase 3:\n\t\t\treturn parseInt(args[0]) * 60 * 60 + parseInt(args[1]) * 60 + parseInt(args[2]);\n\t\t\tbreak;\n\n\t\tcase 2:\n\t\t\treturn parseInt(args[0]) * 60 + parseInt(args[1]);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn parseInt(args[0]);\n\t\t\tbreak;\n\t}\n}\n"]}