{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../src/services/Arbitrary/index.ts"],"names":[],"mappings":";;;;;;AAMA,kDAA0B;AAE1B,yCAA0C;AAC1C,mCAAkD;AAClD,oEAAsC;AAEtC,MAAM,sBAAsB,GAAa,CAAC,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,CAAC,CAAC;AAGzD,QAAA,qBAAqB,GAAG,IAAI,MAAM,CAC9C,gCAAgC,sBAAsB,CAAC,IAAI,CAAC,GAAG,CAAC,IAAI,CACpE,CAAC;AAOK,KAAK,UAAU,cAAc,CAAC,GAAW,EAAE,UAAe;IAChE,GAAG,GAAG,GAAG,CAAC,IAAI,EAAE,CAAC;IACjB,IAAI,CAAC,GAAG;QAAE,MAAM,8BAA8B,CAAC;IAC/C,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,6BAAqB,CAAC;QACpC,MAAM,sDAAsD,CAAC;IAG9D,MAAM,EAAE,IAAI,EAAE,OAAO,EAAE,GAAG,MAAM,eAAK;SACnC,GAAG,CAAC,GAAG,EAAE,EAAE,YAAY,EAAE,QAAQ,EAAE,GAAG,UAAU,EAAE,CAAC;SACnD,KAAK,CAAC,CAAC,GAAG,EAAE,EAAE;QACd,MAAM,GAAG,CAAC;IACX,CAAC,CAAC,CAAC;IACJ,IAAI,CAAC,IAAI;QAAE,MAAM,sCAAsC,CAAC;IAGxD,IAAA,eAAQ,EAAC,2BAA2B,OAAO,CAAC,cAAc,CAAC,EAAE,CAAC,CAAC;IAE/D,OAAO,IAAA,+BAAuB,EAAC;QAC9B,GAAG,EAAE,GAAG;QACR,IAAI,EAAE,IAAI;QACV,OAAO,EAAE,OAAO;QAEhB,IAAI,EAAE,MAAM,wBAAQ,CAAC,WAAW,CAAC,IAAI,EAAE,SAAS,EAAE,EAAE,QAAQ,EAAE,IAAI,EAAE,CAAC;KACrE,CAAC,CAAC;AAIJ,CAAC;AA3BD,wCA2BC;AAKD,SAAgB,kBAAkB,CAAC,GAAW;IAC7C,OAAO,GAAG,CAAC,KAAK,CAAC,6BAAqB,CAAC,CAAC;AACzC,CAAC;AAFD,gDAEC","sourcesContent":["/**\r\n * Avoxel284 2022\r\n * Barbara Music Module / Arbitrary\r\n */\r\n\r\nimport { BarbaraType, MusicPlaylist, MusicTrack, Service } from \"../../lib\";\r\nimport axios from \"axios\";\r\nimport { getKey } from \"../../lib/config\";\r\nimport { debugLog } from \"../../lib/util\";\r\nimport { MusicTrackFromAudioFile } from \"./parse\";\r\nimport metadata from \"music-metadata\";\r\n\r\nconst acceptedFileExtensions: string[] = [\"mp3\", \"mp4\", \"ogg\", \"wav\"];\r\n\r\n/** Pattern for validating Audio file URLs */\r\nexport const AUDIOFILE_URL_PATTERN = new RegExp(\r\n\t`^(https?):\\/\\/(www.)?(.*?)\\.(${acceptedFileExtensions.join(\"|\")})$`\r\n);\r\n\r\n/**\r\n * Returns {@link MusicTrack} with data from a given audio file URL\r\n *\r\n * @param reqOptions Additional options to pass to Axios when creating request (Refer to Axios documentation)\r\n */\r\nexport async function AudioFile_Info(url: string, reqOptions: any): Promise<MusicTrack> {\r\n\turl = url.trim();\r\n\tif (!url) throw \"Given AudioFile URL is null!\";\r\n\tif (!url.match(AUDIOFILE_URL_PATTERN))\r\n\t\tthrow \"Given AudioFile URL is invalid or not an audio file.\";\r\n\t// debugLog(data);\r\n\r\n\tconst { data, headers } = await axios\r\n\t\t.get(url, { responseType: \"stream\", ...reqOptions })\r\n\t\t.catch((err) => {\r\n\t\t\tthrow err;\r\n\t\t});\r\n\tif (!data) throw \"Audio file does not contain any data\";\r\n\t// if (!data?.meta?.format?.duration) throw \"Failed to parse file metadata: Duration is null\";\r\n\r\n\tdebugLog(`AudioFile Content Type: ${headers[\"content-type\"]}`);\r\n\r\n\treturn MusicTrackFromAudioFile({\r\n\t\turl: url,\r\n\t\tdata: data,\r\n\t\theaders: headers,\r\n\t\t// gonna leave duration as true for now\r\n\t\tmeta: await metadata.parseStream(data, undefined, { duration: true }),\r\n\t});\r\n\r\n\t// call it unneccessary but at least all the data is in original data\r\n\t// and its neater/more modular this way\r\n}\r\n\r\n/**\r\n * Check a URL and validate if it is a Audio File URL\r\n */\r\nexport function AudioFile_Validate(url: string) {\r\n\treturn url.match(AUDIOFILE_URL_PATTERN);\r\n}\r\n"]}