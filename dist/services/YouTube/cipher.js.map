{"version":3,"file":"cipher.js","sourceRoot":"","sources":["../../../src/services/YouTube/cipher.ts"],"names":[],"mappings":"","sourcesContent":["// /**\n//  * Avoxel284 2022\n//  * Barbara Music Module / YouTube\n//  * \n//  * Module to decipher audio formats since YouTube does some wacky ciphering stuff\n//  * Most of the code was ripped from play-dl\n//  */\n\n// import { URL, URLSearchParams } from \"node:url\";\n// // import { request } from \"./../../Request\";\n// import axios from \"axios\";\n\n// interface formatOptions {\n// \turl?: string;\n// \tsp?: string;\n// \tsignatureCipher?: string;\n// \tcipher?: string;\n// \ts?: string;\n// }\n\n// const VAR_JS_REGEX = \"[a-zA-Z_\\\\$]\\\\w*\";\n// const SINGLEQUOTE_JS_REGEX = `'[^'\\\\\\\\]*(:?\\\\\\\\[\\\\s\\\\S][^'\\\\\\\\]*)*'`;\n// const DOUBLEQUOTE_JS_REGEX = `\"[^\"\\\\\\\\]*(:?\\\\\\\\[\\\\s\\\\S][^\"\\\\\\\\]*)*\"`;\n// const QUOTE_JS_REGEX = `(?:${SINGLEQUOTE_JS_REGEX}|${DOUBLEQUOTE_JS_REGEX})`;\n// const KEY_JS_REGEX = `(?:${VAR_JS_REGEX}|${QUOTE_JS_REGEX})`;\n// const PROP_JS_REGEX = `(?:\\\\.${VAR_JS_REGEX}|\\\\[${QUOTE_JS_REGEX}\\\\])`;\n// const EMPTY_JS_REGEX = `(?:''|\"\")`;\n// const REVERSE_FUNCTION_REGEX = \":function\\\\(a\\\\)\\\\{\" + \"(?:return )?a\\\\.reverse\\\\(\\\\)\" + \"\\\\}\";\n// const SLICE_FUNCTION_REGEX = \":function\\\\(a,b\\\\)\\\\{\" + \"return a\\\\.slice\\\\(b\\\\)\" + \"\\\\}\";\n// const SPLICE_FUNCTION_REGEX = \":function\\\\(a,b\\\\)\\\\{\" + \"a\\\\.splice\\\\(0,b\\\\)\" + \"\\\\}\";\n// const SWAP_FUNCTION_REGEX =\n// \t\":function\\\\(a,b\\\\)\\\\{\" +\n// \t\"var c=a\\\\[0\\\\];a\\\\[0\\\\]=a\\\\[b(?:%a\\\\.length)?\\\\];a\\\\[b(?:%a\\\\.length)?\\\\]=c(?:;return a)?\" +\n// \t\"\\\\}\";\n// const OBJ_REGEXP = new RegExp(\n// \t`var (${VAR_JS_REGEX})=\\\\{((?:(?:${KEY_JS_REGEX}${REVERSE_FUNCTION_REGEX}|${KEY_JS_REGEX}${SLICE_FUNCTION_REGEX}|${KEY_JS_REGEX}${SPLICE_FUNCTION_REGEX}|${KEY_JS_REGEX}${SWAP_FUNCTION_REGEX}),?\\\\r?\\\\n?)+)\\\\};`\n// );\n// const FUNCTION_REGEXP = new RegExp(\n// \t`${\n// \t\t`function(?: ${VAR_JS_REGEX})?\\\\(a\\\\)\\\\{` +\n// \t\t`a=a\\\\.split\\\\(${EMPTY_JS_REGEX}\\\\);\\\\s*` +\n// \t\t`((?:(?:a=)?${VAR_JS_REGEX}`\n// \t}${PROP_JS_REGEX}\\\\(a,\\\\d+\\\\);)+)` +\n// \t\t`return a\\\\.join\\\\(${EMPTY_JS_REGEX}\\\\)` +\n// \t\t`\\\\}`\n// );\n// const REVERSE_REGEXP = new RegExp(`(?:^|,)(${KEY_JS_REGEX})${REVERSE_FUNCTION_REGEX}`, \"m\");\n// const SLICE_REGEXP = new RegExp(`(?:^|,)(${KEY_JS_REGEX})${SLICE_FUNCTION_REGEX}`, \"m\");\n// const SPLICE_REGEXP = new RegExp(`(?:^|,)(${KEY_JS_REGEX})${SPLICE_FUNCTION_REGEX}`, \"m\");\n// const SWAP_REGEXP = new RegExp(`(?:^|,)(${KEY_JS_REGEX})${SWAP_FUNCTION_REGEX}`, \"m\");\n// /**\n//  * Function to get tokens from html5player body data.\n//  * @param body body data of html5player.\n//  * @returns Array of tokens.\n//  */\n// function js_tokens(body: string) {\n// \tconst function_action = FUNCTION_REGEXP.exec(body);\n// \tconst object_action = OBJ_REGEXP.exec(body);\n// \tif (!function_action || !object_action) return null;\n\n// \tconst object = object_action[1].replace(/\\$/g, \"\\\\$\");\n// \tconst object_body = object_action[2].replace(/\\$/g, \"\\\\$\");\n// \tconst function_body = function_action[1].replace(/\\$/g, \"\\\\$\");\n\n// \tlet result = REVERSE_REGEXP.exec(object_body);\n// \tconst reverseKey = result && result[1].replace(/\\$/g, \"\\\\$\").replace(/\\$|^'|^\"|'$|\"$/g, \"\");\n\n// \tresult = SLICE_REGEXP.exec(object_body);\n// \tconst sliceKey = result && result[1].replace(/\\$/g, \"\\\\$\").replace(/\\$|^'|^\"|'$|\"$/g, \"\");\n\n// \tresult = SPLICE_REGEXP.exec(object_body);\n// \tconst spliceKey = result && result[1].replace(/\\$/g, \"\\\\$\").replace(/\\$|^'|^\"|'$|\"$/g, \"\");\n\n// \tresult = SWAP_REGEXP.exec(object_body);\n// \tconst swapKey = result && result[1].replace(/\\$/g, \"\\\\$\").replace(/\\$|^'|^\"|'$|\"$/g, \"\");\n\n// \tconst keys = `(${[reverseKey, sliceKey, spliceKey, swapKey].join(\"|\")})`;\n// \tconst myreg = `(?:a=)?${object}(?:\\\\.${keys}|\\\\['${keys}'\\\\]|\\\\[\"${keys}\"\\\\])` + `\\\\(a,(\\\\d+)\\\\)`;\n// \tconst tokenizeRegexp = new RegExp(myreg, \"g\");\n// \tconst tokens = [];\n// \twhile ((result = tokenizeRegexp.exec(function_body)) !== null) {\n// \t\tconst key = result[1] || result[2] || result[3];\n// \t\tswitch (key) {\n// \t\t\tcase swapKey:\n// \t\t\t\ttokens.push(`sw${result[4]}`);\n// \t\t\t\tbreak;\n// \t\t\tcase reverseKey:\n// \t\t\t\ttokens.push(\"rv\");\n// \t\t\t\tbreak;\n// \t\t\tcase sliceKey:\n// \t\t\t\ttokens.push(`sl${result[4]}`);\n// \t\t\t\tbreak;\n// \t\t\tcase spliceKey:\n// \t\t\t\ttokens.push(`sp${result[4]}`);\n// \t\t\t\tbreak;\n// \t\t}\n// \t}\n// \treturn tokens;\n// }\n// /**\n//  * Function to decipher signature\n//  * @param tokens Tokens from js_tokens function\n//  * @param signature Signatured format url\n//  * @returns deciphered signature\n//  */\n// function deciper_signature(tokens: string[], signature: string) {\n// \tlet sig = signature.split(\"\");\n// \tconst len = tokens.length;\n// \tfor (let i = 0; i < len; i++) {\n// \t\tlet token = tokens[i],\n// \t\t\tpos;\n// \t\tswitch (token.slice(0, 2)) {\n// \t\t\tcase \"sw\":\n// \t\t\t\tpos = parseInt(token.slice(2));\n// \t\t\t\tswappositions(sig, pos);\n// \t\t\t\tbreak;\n// \t\t\tcase \"rv\":\n// \t\t\t\tsig.reverse();\n// \t\t\t\tbreak;\n// \t\t\tcase \"sl\":\n// \t\t\t\tpos = parseInt(token.slice(2));\n// \t\t\t\tsig = sig.slice(pos);\n// \t\t\t\tbreak;\n// \t\t\tcase \"sp\":\n// \t\t\t\tpos = parseInt(token.slice(2));\n// \t\t\t\tsig.splice(0, pos);\n// \t\t\t\tbreak;\n// \t\t}\n// \t}\n// \treturn sig.join(\"\");\n// }\n// /**\n//  * Function to swap positions in a array\n//  * @param array array\n//  * @param position position to switch with first element\n//  */\n// function swappositions(array: string[], position: number) {\n// \tconst first = array[0];\n// \tarray[0] = array[position];\n// \tarray[position] = first;\n// }\n// /**\n//  * Sets Download url with some extra parameter\n//  * @param format video fomat\n//  * @param sig deciphered signature\n//  * @returns void\n//  */\n// function download_url(format: formatOptions, sig: string) {\n// \tif (!format.url) return;\n\n// \tconst decoded_url = decodeURIComponent(format.url);\n\n// \tconst parsed_url = new URL(decoded_url);\n// \tparsed_url.searchParams.set(\"ratebypass\", \"yes\");\n\n// \tif (sig) {\n// \t\tparsed_url.searchParams.set(format.sp || \"signature\", sig);\n// \t}\n// \tformat.url = parsed_url.toString();\n// }\n// /**\n//  * Main function which handles all queries related to video format deciphering\n//  * @param formats video formats\n//  * @param html5player url of html5player\n//  * @returns array of format.\n//  */\n// export async function format_decipher(\n// \tformats: formatOptions[],\n// \thtml5player: string\n// ): Promise<formatOptions[]> {\n// \tconst body = await request(html5player);\n// \tconst tokens = js_tokens(body);\n// \tformats.forEach((format) => {\n// \t\tconst cipher = format.signatureCipher || format.cipher;\n// \t\tif (cipher) {\n// \t\t\tconst params = Object.fromEntries(new URLSearchParams(cipher));\n// \t\t\tObject.assign(format, params);\n// \t\t\tdelete format.signatureCipher;\n// \t\t\tdelete format.cipher;\n// \t\t}\n// \t\tif (tokens && format.s) {\n// \t\t\tconst sig = deciper_signature(tokens, format.s);\n// \t\t\tdownload_url(format, sig);\n// \t\t\tdelete format.s;\n// \t\t\tdelete format.sp;\n// \t\t}\n// \t});\n// \treturn formats;\n// }\n"]}