{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/classes/index.ts"],"names":[],"mappings":"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","sourcesContent":["import { Readable } from \"stream\";\nimport { getTimeFromSeconds } from \"../util\";\nimport prism from \"prism-media\";\nimport axios from \"axios\";\nimport { getKey } from \"../auth\";\n\nlet clientId = getKey(\"soundcloudClientId\");\n\nexport interface SearchOptions {\n\t/** Service to search track on */\n\tservice: Service;\n\t/** Maximum results to return */\n\tlimit: number;\n\t/**\n\t * Type of results to return\n\t * In the case of YouTube, `tracks` are videos, `playlists` are playlists and `albums` are.. not a thing\n\t */\n\ttype: \"tracks\" | \"playlists\" | \"albums\";\n}\n\nexport interface InfoOptions {\n\t/** Amount of results to return */\n\tlength: number;\n}\n\n/** Type of media - Is it a MusicTrack or MusicPlaylist? */\nexport type BarbaraType = MusicTrack | MusicPlaylist;\n\nexport enum Service {\n\t/** Spotify */\n\tspotify = \"spotify\",\n\t/** YouTube */\n\tyoutube = \"youtube\",\n\t/** SoundCloud */\n\tsoundcloud = \"soundcloud\",\n\t/** Audio File */\n\taudiofile = \"audiofile\",\n}\n\n/** An audio format */\ninterface Audio {\n\t/** Audio URL */\n\turl?: string;\n\t/** Audio quality */\n\tquality?: string;\n\t/** Audio duration **in seconds** */\n\tduration?: number;\n\t/** Audio protocol */\n\tprotocol?: string;\n\t/** Audio mime type */\n\tmimeType?: string;\n}\n\ninterface Thumbnail {\n\t/** Thumbnail URL */\n\turl: string;\n}\n\ninterface Author {\n\t/** Public page URL */\n\turl?: string;\n\t/** Avatar/Profile picture/Channel icon URL */\n\tavatar?: string;\n\t/** Name of author */\n\tname?: string;\n\t/** ID of author */\n\tid?: string;\n\t/** Is the author verified? */\n\tverified?: boolean;\n}\n\nexport class MusicTrack {\n\t/** Friendly URL of the track (e.g. https://youtube.com/watch?v=videoid) */\n\turl: string;\n\n\t/** Name of the track */\n\tname: string;\n\n\t/** ID of user that queued/played the track */\n\tqueuedBy?: string;\n\n\t/** Duration of the track **in seconds** */\n\tduration: number;\n\n\t/** Duration of the track **in timestamp** (e.g. `12:34`) */\n\tdurationTimestamp?: string;\n\n\t/** Has the track been playlisted? */\n\tplaylisted: boolean;\n\n\t/** The service providing track */\n\tservice?: Service;\n\n\t/** Thumbnail of the track */\n\tthumbnail?: Thumbnail;\n\n\t/** Array of media urls */\n\taudio?: Array<Audio>;\n\n\t/** Author of music track. For example, a YouTube channel or SoundCloud user profile */\n\tauthor?: Author;\n\n\t/**\n\t * Original data retreieved from request to service's API.\n\t * There for debug and if theres any metadata not included in MusicTrack itself.\n\t */\n\toriginalData?: any;\n\n\t/**\n\t * An object that represents a music track\n\t *\n\t * @param {Object} data An object containing data. Reference below:\n\t * ```\n\t * url: Public URL\n\t * name: Track name\n\t * thumbnail: Thumbnail object { url: Thumbnail URL }\n\t * queuedBy: Who queued the track\n\t * duration\n\t * ```\n\t * @example\n\t * ```\n\t * let Track = new MusicTrack();\n\t * console.log(Track.url);\n\t * console.log(Track.name);\n\t * console.log(Tack.duration);\n\t * ```\n\t */\n\tconstructor(data: any = {}) {\n\t\tthis.url = data.url || \"\";\n\t\tthis.name = data.name || \"Unnamed MusicTrack\";\n\t\tthis.thumbnail = data.thumbnail;\n\t\tthis.queuedBy = data.queuedBy;\n\t\tthis.duration = data.duration || 0;\n\t\tthis.durationTimestamp = getTimeFromSeconds(data.duration || 0);\n\t\tthis.playlisted = data.playlisted || false;\n\t\tthis.service = data.service;\n\t\tthis.audio = data.audio;\n\t\tthis.author = data.author;\n\t\tthis.originalData = data.originalData;\n\t}\n\n\t/**\n\t * Barbara will sing the track for you. Just kidding.\n\t * Returns a Prism Media FFmpeg object for use with Discord Voice.\n\t *\n\t * @example\n\t * ```\n\t * const resource = await discordVoice.createAudioResource(Track.sing());\n\t *\n\t * ```\n\t *\n\t * @param seek Number of seconds to seek in the track. Obviously defaults to 0\n\t * @param extraArgs An array of extra arguments to pass to Prism when creating the FFmpeg object.\n\t * Basically just your standarad FFmpeg arguments but in array form. For example:\n\t * ```\n\t * \"-f\",\n\t * \"opus\",\n\t * \"-ar\",\n\t * \"48000\",\n\t * \"-ac\",\n\t * \"2\"\n\t * ```\n\t */\n\tasync sing(seek: number = 0, extraArgs?: any[]) {\n\t\tif (seek < 0 || seek > this.duration) throw new Error(\"Seek is out of range of track\");\n\t\tconst args: any[] = [\n\t\t\t\"-ss\",\n\t\t\tseek,\n\t\t\t\"-i\",\n\t\t\t(await this.bestAudio()).url,\n\t\t\t// \"-analyzeduration\",\n\t\t\t// \"0\",\n\t\t\t// \"-loglevel\",\n\t\t\t// \"48\",\n\t\t\t// \"-f\",\n\t\t\t// \"opus\",\n\t\t\t// \"-ar\",\n\t\t\t// \"48000\",\n\t\t\t\"-ac\",\n\t\t\t\"2\",\n\t\t];\n\t\tif (extraArgs) args.push(...extraArgs);\n\n\t\treturn new prism.FFmpeg({ args: args });\n\t}\n\n\t/**\n\t * Returns the best audio format.\n\t * **Note:** if SoundCloud is the service, `Audio.url` is changed to a time sensitive URL due to SoundCloud APIs.\n\t */\n\tasync bestAudio(): Promise<Audio> {\n\t\tif (this.audio == undefined || this.audio?.length == 0)\n\t\t\tthrow new Error(\"MusicTrack does not contain any audios\");\n\n\t\tif (this.service === Service.spotify) {\n\t\t\tthrow new Error(\"Spotify does not provide streaming, thus cannot return best audio\");\n\t\t}\n\n\t\tif (this.service === Service.soundcloud) {\n\t\t\tconsole.log(this.audio);\n\t\t\tlet best = this.audio\n\t\t\t\t.filter((a: Audio) => (a.mimeType ? a.mimeType.includes(\"audio/mpeg\") : false))\n\t\t\t\t.filter((a: Audio) => a.protocol?.includes(\"progressive\"))\n\t\t\t\t.filter((a: Audio) =>\n\t\t\t\t\ta.quality\n\t\t\t\t\t\t? a.quality.includes(\"sq\") || a.quality.includes(\"medium\") || a.quality.includes(\"low\")\n\t\t\t\t\t\t: false\n\t\t\t\t)?.[0];\n\t\t\tconsole.log(best);\n\n\t\t\tlet { data } = await axios.get(`${best.url}`).catch((err: Error) => {\n\t\t\t\tthrow err;\n\t\t\t});\n\t\t\tbest.url = data.url;\n\t\t\treturn best;\n\t\t}\n\n\t\tif (this.service === Service.youtube) {\n\t\t\treturn this.audio[0];\n\t\t}\n\n\t\treturn {};\n\t}\n}\n\nexport class MusicPlaylist {\n\t/** Friendly URL of the playlist */\n\turl?: string;\n\n\t/** Name of the playlist */\n\tname?: string;\n\n\t/** Duration of all the tracks **in seconds** */\n\tduration?: number;\n\n\t/** Duration of all the tracks **in timestamp** (e.g. `12:34`) */\n\tdurationTimestamp?: string;\n\n\t/** Is the playlist an album? */\n\tisAlbum?: boolean;\n\n\t/** Array of MusicTracks in playlist */\n\ttracks?: MusicTrack[];\n\n\t/** Author of playlist. For example, a YouTube channel or SoundCloud user profile */\n\tauthor?: Author;\n\n\t/** The service providing track */\n\tservice?: Service;\n\n\t/** Thumbnail of the playlist */\n\tthumbnail?: Thumbnail;\n\n\t/**\n\t * Original data retreieved from request to service's API.\n\t * There for debug and if theres any metadata not included in MusicTrack itself.\n\t */\n\toriginalData?: any;\n\n\tconstructor(data: any = {}) {\n\t\tthis.url = data.url;\n\t\tthis.name = data.name;\n\t\tthis.duration = data.duration;\n\t\tthis.durationTimestamp = getTimeFromSeconds(data.duration);\n\t\tthis.isAlbum = data.isAlbum;\n\t\tthis.tracks = data.tracks;\n\t\tthis.service = data.service;\n\t\tthis.thumbnail = data.thumbnail;\n\t\tthis.author = data.author;\n\t\tthis.originalData = data.originalData;\n\t}\n}\n\nexport class BarbaraStream {\n\t/** Readable stream */\n\tstream?: Readable;\n\n\t/** The service providing track */\n\tservice?: Service;\n\n\t/** URL that the stream is using */\n\turl?: string;\n\n\tconstructor(data: any = {}) {\n\t\tthis.url = data.url;\n\t\tthis.stream = data.stream;\n\t\tthis.service = data.service;\n\t}\n}\n"]}