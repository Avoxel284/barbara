{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/classes/index.ts"],"names":[],"mappings":"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","sourcesContent":["import { Readable } from \"stream\";\r\nimport { getTimeFromSeconds } from \"../util\";\r\nimport prism from \"prism-media\";\r\nimport axios from \"axios\";\r\nimport { getKey, isDebug } from \"../config\";\r\n\r\nlet clientId = getKey(\"soundcloudClientId\");\r\n\r\nexport interface SearchOptions {\r\n\t/** Service to search track on */\r\n\tservice: Service;\r\n\t/** Maximum results to return */\r\n\tlimit: number;\r\n\t/**\r\n\t * Type of results to return\r\n\t * In the case of YouTube, `tracks` are videos, `playlists` are playlists and `albums` are.. not a thing\r\n\t */\r\n\ttype: \"tracks\" | \"playlists\" | \"albums\";\r\n}\r\n\r\nexport interface InfoOptions {\r\n\t/** Amount of results to return */\r\n\tlength: number;\r\n}\r\n\r\n/** Type of media - Is it a MusicTrack or MusicPlaylist? */\r\nexport type BarbaraType = MusicTrack | MusicPlaylist;\r\n\r\nexport enum Service {\r\n\t/** Spotify */\r\n\tspotify = \"spotify\",\r\n\t/** YouTube */\r\n\tyoutube = \"youtube\",\r\n\t/** SoundCloud */\r\n\tsoundcloud = \"soundcloud\",\r\n\t/** Audio File */\r\n\taudiofile = \"audiofile\",\r\n}\r\n\r\n/** An audio format */\r\nexport interface Audio {\r\n\t/** Audio URL */\r\n\turl?: string;\r\n\t/** Audio quality */\r\n\tquality?: string;\r\n\t/** Audio duration **in seconds** */\r\n\tduration?: number;\r\n\t/** Audio protocol */\r\n\tprotocol?: string;\r\n\t/** Audio mime type */\r\n\tmimeType?: string;\r\n}\r\n\r\ninterface Author {\r\n\t/** Public page URL */\r\n\turl?: string;\r\n\t/** Avatar/Profile picture/Channel icon URL */\r\n\tavatar?: string;\r\n\t/** Name of author */\r\n\tname?: string;\r\n\t/** ID of author */\r\n\tid?: string;\r\n\t/** Is the author verified? */\r\n\tverified?: boolean;\r\n}\r\n\r\nexport class MusicTrack {\r\n\t/** Friendly URL of the track (e.g. https://youtube.com/watch?v=videoid) */\r\n\turl: string;\r\n\r\n\t/** Name of the track */\r\n\tname: string;\r\n\r\n\t/** ID of the track (e.g. https://www.youtube.com/watch?v=dQw4w9WgXcQ --> `dQw4w9WgXcQ`) */\r\n\tid: string;\r\n\r\n\t/** ID of user that queued/played the track */\r\n\tqueuedBy?: string;\r\n\r\n\t/** Duration of the track **in seconds** */\r\n\tduration: number;\r\n\r\n\t/** Duration of the track **in timestamp** (e.g. `12:34`) */\r\n\tdurationTimestamp?: string;\r\n\r\n\t/** Is the track live-streaming? (e.g. a YouTube livestream) */\r\n\tlive: boolean;\r\n\r\n\t/** Has the track been playlisted? */\r\n\tplaylisted: boolean;\r\n\r\n\t/** The service providing track (e.g. YouTube) */\r\n\tservice?: Service;\r\n\r\n\t/** Thumbnail URL of the track */\r\n\tthumbnail?: string;\r\n\r\n\t/** Array of media urls */\r\n\taudio?: Array<Audio>;\r\n\r\n\t/** Author of music track. For example, a YouTube channel or SoundCloud user profile */\r\n\tauthor?: Author;\r\n\r\n\t/**\r\n\t * Original data retreieved from request to service's API.\r\n\t * There for debug and if theres any metadata not included in MusicTrack itself.\r\n\t */\r\n\toriginalData?: any;\r\n\r\n\t/**\r\n\t * An object that represents a music track\r\n\t *\r\n\t * @param {Object} data An object containing data. Reference below:\r\n\t * ```\r\n\t * url: Public URL\r\n\t * name: Track name\r\n\t * thumbnail: Thumbnail object { url: Thumbnail URL }\r\n\t * queuedBy: Who queued the track\r\n\t * duration\r\n\t * ```\r\n\t * @example\r\n\t * ```\r\n\t * let Track = new MusicTrack();\r\n\t * console.log(Track.url);\r\n\t * console.log(Track.name);\r\n\t * console.log(Tack.duration);\r\n\t * ```\r\n\t */\r\n\tconstructor(data: any = {}) {\r\n\t\tthis.url = data.url || \"\";\r\n\t\tthis.name = data.name || \"Unnamed MusicTrack\";\r\n\t\tthis.id = data.id;\r\n\t\tthis.thumbnail = data.thumbnail;\r\n\t\tthis.queuedBy = data.queuedBy;\r\n\t\tthis.duration = data.duration || 0;\r\n\t\tthis.durationTimestamp = getTimeFromSeconds(data.duration || 0);\r\n\t\tthis.live = data.live;\r\n\t\tthis.playlisted = data.playlisted || false;\r\n\t\tthis.service = data.service;\r\n\t\tthis.audio = data.audio;\r\n\t\tthis.author = data.author;\r\n\t\tthis.originalData = data.originalData;\r\n\t}\r\n\r\n\t/**\r\n\t * Barbara will sing the track for you. Just kidding.\r\n\t * Returns a Prism Media FFmpeg object for use with Discord Voice.\r\n\t *\r\n\t * @example\r\n\t * ```\r\n\t * const resource = await discordVoice.createAudioResource(Track.sing());\r\n\t *\r\n\t * ```\r\n\t *\r\n\t * @param seek Number of seconds to seek in the track. Obviously defaults to 0\r\n\t * @param extraArgs An array of extra arguments to pass to Prism when creating the FFmpeg object.\r\n\t * Basically just your standarad FFmpeg arguments but in array form. For example:\r\n\t * ```\r\n\t * \"-ar\",\r\n\t * \"48000\",\r\n\t * \"-ac\",\r\n\t * \"2\"\r\n\t * ```\r\n\t */\r\n\tasync sing(seek: number = 0, extraArgs?: any[]) {\r\n\t\tif (seek < 0 || seek > this.duration) throw new Error(\"Seek is out of range of track\");\r\n\t\tconst args: any[] = [\r\n\t\t\t\"-ss\",\r\n\t\t\tseek,\r\n\t\t\t\"-i\",\r\n\t\t\t(await this.bestAudio()).url,\r\n\t\t\t// \"-analyzeduration\",\r\n\t\t\t// \"0\",\r\n\t\t\t// \"-loglevel\",\r\n\t\t\t// \"48\",\r\n\t\t\t\"-f\",\r\n\t\t\t\"opus\",\r\n\t\t\t// \"-ar\",\r\n\t\t\t// \"48000\",\r\n\t\t\t\"-ac\",\r\n\t\t\t\"2\",\r\n\t\t];\r\n\t\tif (extraArgs) args.push(...extraArgs);\r\n\r\n\t\treturn new prism.FFmpeg({ args: args });\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the best audio format.\r\n\t * **Note:** if SoundCloud is the service, `Audio.url` is changed to a time sensitive URL due to SoundCloud APIs.\r\n\t */\r\n\tasync bestAudio(): Promise<Audio> {\r\n\t\tif (this.audio == undefined || this.audio?.length == 0)\r\n\t\t\tthrow new Error(\"MusicTrack does not contain any audios\");\r\n\r\n\t\tif (this.service === Service.spotify) {\r\n\t\t\tthrow new Error(\"Spotify does not provide streaming, thus cannot return best audio\");\r\n\t\t}\r\n\r\n\t\tif (this.service === Service.soundcloud) {\r\n\t\t\tif (isDebug()) console.log(this.audio);\r\n\t\t\tlet best = this.audio\r\n\t\t\t\t.filter((a: Audio) => (a.mimeType ? a.mimeType.includes(\"audio/mpeg\") : false))\r\n\t\t\t\t.filter((a: Audio) => a.protocol?.includes(\"progressive\"))\r\n\t\t\t\t.filter((a: Audio) =>\r\n\t\t\t\t\ta.quality\r\n\t\t\t\t\t\t? a.quality.includes(\"sq\") || a.quality.includes(\"medium\") || a.quality.includes(\"low\")\r\n\t\t\t\t\t\t: false\r\n\t\t\t\t)?.[0];\r\n\t\t\tif (isDebug()) console.log(best);\r\n\r\n\t\t\tlet { data } = await axios.get(`${best.url}`).catch((err: Error) => {\r\n\t\t\t\tthrow err;\r\n\t\t\t});\r\n\t\t\tbest.url = data.url;\r\n\t\t\treturn best;\r\n\t\t}\r\n\r\n\t\tif (this.service === Service.youtube) {\r\n\t\t\treturn this.audio[0];\r\n\t\t}\r\n\r\n\t\treturn {};\r\n\t}\r\n\r\n\t/**\r\n\t * Checks the track for missing data and fetches it. Useful for YouTube searches where the data doesn't return audios\r\n\t */\r\n\tasync fetchFullTrack() {\r\n\t\tif (this.service === Service.youtube) {\r\n\t\t}\r\n\t}\r\n}\r\n\r\nexport class MusicPlaylist {\r\n\t/** Friendly URL of the playlist */\r\n\turl?: string;\r\n\r\n\t/** Name of the playlist */\r\n\tname?: string;\r\n\r\n\t/** Duration of all the tracks **in seconds** */\r\n\tduration?: number;\r\n\r\n\t/** Duration of all the tracks **in timestamp** (e.g. `12:34`) */\r\n\tdurationTimestamp?: string;\r\n\r\n\t/** Is the playlist an album? */\r\n\tisAlbum?: boolean;\r\n\r\n\t/** Array of MusicTracks in playlist */\r\n\ttracks?: MusicTrack[];\r\n\r\n\t/** Author of playlist. For example, a YouTube channel or SoundCloud user profile */\r\n\tauthor?: Author;\r\n\r\n\t/** The service providing track */\r\n\tservice?: Service;\r\n\r\n\t/** Thumbnail of the playlist */\r\n\tthumbnail?: string;\r\n\r\n\t/**\r\n\t * Original data retreieved from request to service's API.\r\n\t * There for debug and if theres any metadata not included in MusicTrack itself.\r\n\t */\r\n\toriginalData?: any;\r\n\r\n\tconstructor(data: any = {}) {\r\n\t\tthis.url = data.url;\r\n\t\tthis.name = data.name;\r\n\t\tthis.duration = data.duration;\r\n\t\tthis.durationTimestamp = getTimeFromSeconds(data.duration);\r\n\t\tthis.isAlbum = data.isAlbum;\r\n\t\tthis.tracks = data.tracks;\r\n\t\tthis.service = data.service;\r\n\t\tthis.thumbnail = data.thumbnail;\r\n\t\tthis.author = data.author;\r\n\t\tthis.originalData = data.originalData;\r\n\t}\r\n}\r\n\r\nexport class BarbaraStream {\r\n\t/** Readable stream */\r\n\tstream?: Readable;\r\n\r\n\t/** The service providing track */\r\n\tservice?: Service;\r\n\r\n\t/** URL that the stream is using */\r\n\turl?: string;\r\n\r\n\tconstructor(data: any = {}) {\r\n\t\tthis.url = data.url;\r\n\t\tthis.stream = data.stream;\r\n\t\tthis.service = data.service;\r\n\t}\r\n}\r\n"]}